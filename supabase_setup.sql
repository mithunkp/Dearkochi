-- Create Traffic Alerts Table
create table if not exists traffic_alerts (
  id bigint generated by default as identity primary key,
  location text not null,
  status text not null,
  details text,
  severity text check (severity in ('high', 'medium', 'low')),
  time text, -- You can use timestamp type for better handling, using text for simplicity with '10 mins ago' format
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create Fuel Prices Table
create table if not exists fuel_prices (
  id bigint generated by default as identity primary key,
  type text not null,
  price text not null,
  trend text check (trend in ('up', 'stable', 'down')),
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Insert Sample Data for Traffic Alerts
insert into traffic_alerts (location, status, details, severity, time) values
('MG Road', 'Heavy Traffic', 'Construction work near Metro station.', 'high', '10 mins ago'),
('Vyttila Hub', 'Moderate Traffic', 'Signal malfunction causing delays.', 'medium', '25 mins ago'),
('Edappally Bypass', 'Clear', 'Traffic flowing smoothly.', 'low', '5 mins ago');

-- Insert Sample Data for Fuel Prices
insert into fuel_prices (type, price, trend) values
('Petrol', '₹103.58', 'stable'),
('Diesel', '₹94.82', 'up'),
('CNG', '₹85.00', 'stable');

-- Enable Row Level Security (Optional but recommended)
alter table traffic_alerts enable row level security;
alter table fuel_prices enable row level security;

-- Create Policy to allow public read access
create policy "Public traffic alerts are viewable by everyone"
  on traffic_alerts for select
  using ( true );

create policy "Public fuel prices are viewable by everyone"
  on fuel_prices for select
  using ( true );

-- NEW: Create Categories Table
create table if not exists categories (
  id bigint generated by default as identity primary key,
  name text not null,
  slug text not null unique,
  image_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- NEW: Create Stores Table
create table if not exists stores (
  id bigint generated by default as identity primary key,
  name text not null,
  category_id bigint references categories(id) on delete set null,
  description text,
  location text,
  contact_info text,
  user_id uuid references auth.users(id) on delete cascade, -- Link to auth user
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- NEW: Create Profiles Table (for user details)
create table if not exists profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  email text,
  full_name text,
  avatar_url text,
  updated_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for new tables
alter table categories enable row level security;
alter table stores enable row level security;
alter table profiles enable row level security;

-- Policies for new tables
-- Categories: Public read
create policy "Public categories are viewable by everyone" on categories for select using (true);

-- Stores: Public read, Owner write
create policy "Public stores are viewable by everyone" on stores for select using (true);
create policy "Users can insert their own stores" on stores for insert with check (auth.uid() = user_id);
create policy "Users can update their own stores" on stores for update using (auth.uid() = user_id);

-- Profiles: Public read, User write own
create policy "Public profiles are viewable by everyone" on profiles for select using (true);
create policy "Users can insert their own profile" on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile" on profiles for update using (auth.uid() = id);

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

-- Trigger for new user signup
-- Note: You might need to drop the trigger first if it exists to avoid errors when re-running
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Insert Sample Data for Categories
insert into categories (name, slug, image_url) values
('Electronics', 'electronics', 'https://images.unsplash.com/photo-1498049860654-af1a5c5668ba?auto=format&fit=crop&w=500&q=60'),
('Fashion', 'fashion', 'https://images.unsplash.com/photo-1445205170230-053b83016050?auto=format&fit=crop&w=500&q=60'),
('Groceries', 'groceries', 'https://images.unsplash.com/photo-1542838132-92c53300491e?auto=format&fit=crop&w=500&q=60')
on conflict (slug) do nothing;

-- ... (Previous content remains, appending new tables)

-- NEW: Store Ratings Table
create table if not exists store_ratings (
  store_id bigint references stores(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  rating integer check (rating >= 1 and rating <= 5),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (store_id, user_id)
);

-- NEW: Store Comments Table
create table if not exists store_comments (
  id bigint generated by default as identity primary key,
  store_id bigint references stores(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table store_ratings enable row level security;
alter table store_comments enable row level security;

-- Policies for Ratings
create policy "Public ratings are viewable by everyone" on store_ratings for select using (true);
create policy "Users can insert/update their own ratings" on store_ratings for insert with check (auth.uid() = user_id);
create policy "Users can update their own ratings" on store_ratings for update using (auth.uid() = user_id);

-- Policies for Comments
create policy "Public comments are viewable by everyone" on store_comments for select using (true);
create policy "Users can insert their own comments" on store_comments for insert with check (auth.uid() = user_id);
create policy "Users can delete their own comments" on store_comments for delete using (auth.uid() = user_id);

-- Helper function to get average rating
create or replace view store_stats as
select 
  store_id,
  count(rating) as rating_count,
  avg(rating)::numeric(10,1) as average_rating
from store_ratings
group by store_id;
